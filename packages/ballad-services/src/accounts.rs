use std::cell::LazyCell;

use gtk::{glib, subclass::prelude::ObjectSubclassIsExt};

mod dbus {
    //! # D-Bus interface proxy for: `org.freedesktop.Accounts` and `org.freedesktop.Accounts.User`
    //!
    //! This code was generated by `zbus-xmlgen` `4.1.0` from D-Bus introspection data and modified slightly.
    use zbus::proxy;

    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    #[repr(i32)]
    pub enum AccountType {
        StandardUser = 0,
        Administrator = 1,
    }
    impl TryFrom<i32> for AccountType {
        type Error = ();
        fn try_from(value: i32) -> Result<Self, Self::Error> {
            match value {
                0 => Ok(Self::StandardUser),
                1 => Ok(Self::Administrator),
                _ => Err(()),
            }
        }
    }

    #[proxy(
        default_path = "/org/freedesktop/Accounts",
        default_service = "org.freedesktop.Accounts",
        interface = "org.freedesktop.Accounts",
        assume_defaults = true
    )]
    pub trait Accounts {
        /// CacheUser method
        fn cache_user(&self, name: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

        /// CreateUser method
        fn create_user(
            &self,
            name: &str,
            fullname: &str,
            account_type: i32,
        ) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

        /// DeleteUser method
        fn delete_user(&self, id: i64, remove_files: bool) -> zbus::Result<()>;

        /// FindUserById method
        fn find_user_by_id(&self, id: i64) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

        /// FindUserByName method
        fn find_user_by_name(&self, name: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

        /// GetUsersLanguages method
        fn get_users_languages(&self) -> zbus::Result<Vec<String>>;

        /// ListCachedUsers method
        fn list_cached_users(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

        /// UncacheUser method
        fn uncache_user(&self, name: &str) -> zbus::Result<()>;

        /// UserAdded signal
        #[zbus(signal)]
        fn user_added(&self, user: zbus::zvariant::ObjectPath<'_>) -> zbus::Result<()>;

        /// UserDeleted signal
        #[zbus(signal)]
        fn user_deleted(&self, user: zbus::zvariant::ObjectPath<'_>) -> zbus::Result<()>;

        /// AutomaticLoginUsers property
        #[zbus(property)]
        fn automatic_login_users(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

        /// DaemonVersion property
        #[zbus(property)]
        fn daemon_version(&self) -> zbus::Result<String>;

        /// HasMultipleUsers property
        #[zbus(property)]
        fn has_multiple_users(&self) -> zbus::Result<bool>;

        /// HasNoUsers property
        #[zbus(property)]
        fn has_no_users(&self) -> zbus::Result<bool>;
    }

    #[proxy(interface = "org.freedesktop.Accounts.User", assume_defaults = true)]
    pub trait User {
        /// GetPasswordExpirationPolicy method
        fn get_password_expiration_policy(&self) -> zbus::Result<(i64, i64, i64, i64, i64, i64)>;

        /// SetAccountType method
        fn set_account_type(&self, account_type: i32) -> zbus::Result<()>;

        /// SetAutomaticLogin method
        fn set_automatic_login(&self, enabled: bool) -> zbus::Result<()>;

        /// SetEmail method
        fn set_email(&self, email: &str) -> zbus::Result<()>;

        /// SetHomeDirectory method
        fn set_home_directory(&self, homedir: &str) -> zbus::Result<()>;

        /// SetIconFile method
        fn set_icon_file(&self, filename: &str) -> zbus::Result<()>;

        /// SetLanguage method
        fn set_language(&self, language: &str) -> zbus::Result<()>;

        /// SetLanguages method
        fn set_languages(&self, languages: &[&str]) -> zbus::Result<()>;

        /// SetLocation method
        fn set_location(&self, location: &str) -> zbus::Result<()>;

        /// SetLocked method
        fn set_locked(&self, locked: bool) -> zbus::Result<()>;

        /// SetPassword method
        fn set_password(&self, password: &str, hint: &str) -> zbus::Result<()>;

        /// SetPasswordExpirationPolicy method
        fn set_password_expiration_policy(
            &self,
            min_days_between_changes: i64,
            max_days_between_changes: i64,
            days_to_warn: i64,
            days_after_expiration_until_lock: i64,
        ) -> zbus::Result<()>;

        /// SetPasswordHint method
        fn set_password_hint(&self, hint: &str) -> zbus::Result<()>;

        /// SetPasswordMode method
        fn set_password_mode(&self, mode: i32) -> zbus::Result<()>;

        /// SetRealName method
        fn set_real_name(&self, name: &str) -> zbus::Result<()>;

        /// SetSession method
        fn set_session(&self, session: &str) -> zbus::Result<()>;

        /// SetSessionType method
        fn set_session_type(&self, session_type: &str) -> zbus::Result<()>;

        /// SetShell method
        fn set_shell(&self, shell: &str) -> zbus::Result<()>;

        /// SetUserExpirationPolicy method
        fn set_user_expiration_policy(&self, expiration_time: i64) -> zbus::Result<()>;

        /// SetUserName method
        fn set_user_name(&self, name: &str) -> zbus::Result<()>;

        /// SetXSession method
        #[zbus(name = "SetXSession")]
        fn set_xsession(&self, x_session: &str) -> zbus::Result<()>;

        /// Changed signal
        #[zbus(signal)]
        fn changed(&self) -> zbus::Result<()>;

        /// AccountType property
        #[zbus(property)]
        fn account_type(&self) -> zbus::Result<i32>;

        /// AutomaticLogin property
        #[zbus(property)]
        fn automatic_login(&self) -> zbus::Result<bool>;

        /// Email property
        #[zbus(property)]
        fn email(&self) -> zbus::Result<String>;

        /// HomeDirectory property
        #[zbus(property)]
        fn home_directory(&self) -> zbus::Result<String>;

        /// IconFile property
        #[zbus(property)]
        fn icon_file(&self) -> zbus::Result<String>;

        /// Language property
        #[zbus(property)]
        fn language(&self) -> zbus::Result<String>;

        /// Languages property
        #[zbus(property)]
        fn languages(&self) -> zbus::Result<Vec<String>>;

        /// LocalAccount property
        #[zbus(property)]
        fn local_account(&self) -> zbus::Result<bool>;

        /// Location property
        #[zbus(property)]
        fn location(&self) -> zbus::Result<String>;

        /// Locked property
        #[zbus(property)]
        fn locked(&self) -> zbus::Result<bool>;

        /// LoginFrequency property
        #[zbus(property)]
        fn login_frequency(&self) -> zbus::Result<u64>;

        /// LoginHistory property
        #[zbus(property)]
        fn login_history(
            &self,
        ) -> zbus::Result<
            Vec<(
                i64,
                i64,
                std::collections::HashMap<String, zbus::zvariant::OwnedValue>,
            )>,
        >;

        /// LoginTime property
        #[zbus(property)]
        fn login_time(&self) -> zbus::Result<i64>;

        /// PasswordHint property
        #[zbus(property)]
        fn password_hint(&self) -> zbus::Result<String>;

        /// PasswordMode property
        #[zbus(property)]
        fn password_mode(&self) -> zbus::Result<i32>;

        /// RealName property
        #[zbus(property)]
        fn real_name(&self) -> zbus::Result<String>;

        /// Saved property
        #[zbus(property)]
        fn saved(&self) -> zbus::Result<bool>;

        /// Session property
        #[zbus(property)]
        fn session(&self) -> zbus::Result<String>;

        /// SessionType property
        #[zbus(property)]
        fn session_type(&self) -> zbus::Result<String>;

        /// Shell property
        #[zbus(property)]
        fn shell(&self) -> zbus::Result<String>;

        /// SystemAccount property
        #[zbus(property)]
        fn system_account(&self) -> zbus::Result<bool>;

        /// Uid property
        #[zbus(property)]
        fn uid(&self) -> zbus::Result<u64>;

        /// UserName property
        #[zbus(property)]
        fn user_name(&self) -> zbus::Result<String>;

        /// UsesHomed property
        #[zbus(property)]
        fn uses_homed(&self) -> zbus::Result<bool>;

        /// XSession property
        #[zbus(property, name = "XSession")]
        fn xsession(&self) -> zbus::Result<String>;
    }
}

mod user {
    use std::cell::{Cell, RefCell};
    use std::path::PathBuf;

    use gtk::glib;
    use gtk::{prelude::*, subclass::prelude::*};

    use super::dbus::UserProxy;

    #[derive(Debug, Default, glib::Properties)]
    #[properties(wrapper_type = super::User)]
    pub struct User {
        #[property(get)]
        username: RefCell<String>,
        #[property(get, set)]
        real_name: RefCell<String>,
        #[property(get, set)]
        email: RefCell<String>,
        #[property(get, set)]
        icon_file: RefCell<PathBuf>,
        #[property(get)]
        home_directory: RefCell<PathBuf>,

        #[property(get)]
        uid: Cell<u64>,

        #[property(get)]
        dbus_object_path: RefCell<String>,
    }

    #[glib::object_subclass]
    impl ObjectSubclass for User {
        const NAME: &'static str = "BalladServicesUser";
        type Type = super::User;
    }

    #[glib::derived_properties]
    impl ObjectImpl for User {}
}
mod service {
    use std::cell::RefCell;

    use gtk::glib::{self, clone};
    use gtk::{prelude::*, subclass::prelude::*};
    use smol::channel::Sender;
    use zbus::Connection;

    use super::{User, dbus::AccountsProxy};

    #[derive(Debug, Default, Clone, glib::Boxed)]
    #[boxed_type(name = "BalladServicesUser", nullable)]
    pub struct Users(pub Vec<User>);

    #[derive(Debug, Default, glib::Properties)]
    #[properties(wrapper_type = super::AccountsService)]
    pub struct AccountsService {
        #[property(name = "cached-users", get)]
        cached_users: RefCell<Option<Users>>,
        #[property(get)]
        automatic_login_users: RefCell<Option<Users>>,

        cache_user_sender: RefCell<Option<Sender<String>>>,
    }
    impl AccountsService {
        pub fn cache_user(&self, user: String) {
            if let Some(sender) = self.cache_user_sender.borrow().as_ref() {
                sender.try_send(user).unwrap();
            }
        }
    }

    #[glib::object_subclass]
    impl ObjectSubclass for AccountsService {
        const NAME: &'static str = "BalladServicesAccountsService";
        type Type = super::AccountsService;
    }

    #[glib::derived_properties]
    impl ObjectImpl for AccountsService {
        fn constructed(&self) {
            self.parent_constructed();

            let (sender, receiver) = smol::channel::bounded(1);
            self.cache_user_sender.replace(Some(sender));

            glib::spawn_future_local(clone!(
                #[weak(rename_to = this)]
                self,
                async move {
                    let Ok(connection) = Connection::system().await else {
                        println!(
                            "Failed to connect to the DBus system bus. This is required for getting user accounts!"
                        );
                        return;
                    };
                    let Ok(accounts) = AccountsProxy::new(&connection).await else {
                        println!(
                            "Failed to create a proxy for the AccountsService bus. This is required for getting user accounts!"
                        );
                        return;
                    };

                    let users: Vec<_> = accounts
                        .list_cached_users()
                        .await
                        .unwrap_or_default()
                        .into_iter()
                        .map(|path| User::new(path.to_string()))
                        .collect();

                    this.cached_users.replace(Some(Users(users)));
                    this.obj().notify_cached_users();

                    while let Ok(user) = receiver.recv().await {
                        let path = accounts.cache_user(&user).await.unwrap();
                        let user = User::new(path.to_string());
                        this.cached_users.borrow_mut().as_mut().unwrap().0.push(user);
                        this.obj().notify_cached_users();
                    }
                }
            ));
        }
    }
}

glib::wrapper! {
    pub struct User(ObjectSubclass<user::User>);
}
impl User {
    pub fn new(dbus_object_path: String) -> Self {
        glib::Object::builder()
            .property("dbus-object-path", dbus_object_path)
            .build()
    }
}
glib::wrapper! {
    pub struct AccountsService(ObjectSubclass<service::AccountsService>);
}
impl AccountsService {
    pub fn new() -> Self {
        glib::Object::builder().build()
    }
    pub fn cache_user(&self, name: &str) {
        self.imp().cache_user(name.to_string());
    }
}
impl Default for AccountsService {
    fn default() -> Self {
        Self::new()
    }
}

thread_local! {
    pub static ACCOUNTS_SERVICE: LazyCell<AccountsService> = LazyCell::new(AccountsService::new);
}
